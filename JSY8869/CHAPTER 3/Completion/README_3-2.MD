# Coding_Test CHAPTER 3 그리디
- 당장 좋은 것만 선택하는 그리디
- 현재 상황에서 지금 당장 좋은 것만 고르는 방법
- 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.
- 그리디 알고리즘은 정렬 알고리즘과 자주 짝을 이뤄 출제된다.

# Coding_Test CHAPTER 3-2 큰 수의 법칙
큰 수의 법칙은 일반적으로 통계  분야에서 다루어지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 있다. 동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.

예를 들어 2,4,5,4,6 으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자. 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5인 46이다.
# 조건
### 입력 조건
1. 첫째 줄에 N(2<=N<=1000), M(1<=M<=10,000), K(1<=K<=10,000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
2. 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10,000이하의 수로 주어진다.
3. 입력으로 주어지는 K는 항상 M보다 작거나 같다.
### 출력조건
1. 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.


# 내가 생각한 방법 - Python
## 필요한 변수
1. 배열의 크기 N
2. 더할 횟수 M
3. 연속으로 더할 수 있는 최대 횟수 K
4. N크기의 배열 N_List
5. 결과값 Result
## 알고리즘
    while (Ture)
        for문 (K만큼)
            Result에 가장 큰 수를 K 만큼 더함
            한 번 더할때마다 M에서 1씩 뺌
            if (M이 0이되면)
                종료
        Result에 두번째로 큰 수를 더함
        M에서 1뺌
        if (M이 0이되면)
            종료

# 내가 생각한 방법 - Java
## 필요한 변수
1. short 배열의 크기 N
2. short 더할 횟수 M
3. short 연속으로 더할 수 있는 최대 횟수 K
4. N크기의 배열 N_List
5. int 결과값 Result